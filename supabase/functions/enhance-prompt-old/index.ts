// This file is automatically generated. Do not edit it directly.
import { createClient } from 'https://esm.sh/@supabase/supabase-js@2.50.0';

// CORS headers
const corsHeaders = {
  'Access-Control-Allow-Origin': '*',
  'Access-Control-Allow-Headers': 'authorization, x-client-info, apikey, content-type',
};

Deno.serve(async (req) => {
  console.log('Enhance prompt function called');

  // Handle CORS preflight requests
  if (req.method === 'OPTIONS') {
    return new Response(null, { headers: corsHeaders });
  }

  try {
    const requestData = await req.json();
    console.log('Request data:', JSON.stringify(requestData, null, 2));

    // Validate request
    if (!requestData.prompt) {
      throw new Error('Prompt is required');
    }

    // Initialize the orchestrator and enhance the prompt
    const orchestrator = new ContentCompliantEnhancementOrchestrator();
    const enhancementResult = await orchestrator.enhancePrompt(requestData);

    console.log('Enhancement result:', JSON.stringify(enhancementResult, null, 2));

    return new Response(JSON.stringify(enhancementResult), {
      headers: { ...corsHeaders, 'Content-Type': 'application/json' },
    });

  } catch (error) {
    console.error('Error in enhance-prompt function:', error);
    return new Response(JSON.stringify({ 
      error: error.message,
      enhanced_prompt: requestData?.prompt || '',
      original_prompt: requestData?.prompt || '',
      metadata: {
        strategy: 'error_fallback',
        content_tier: 'unrestricted',
        model_used: 'none',
        enhancement_time_ms: 0
      }
    }), {
      status: 500,
      headers: { ...corsHeaders, 'Content-Type': 'application/json' },
    });
  }
});

/**
 * ContentCompliantEnhancementOrchestrator
 * 
 * Orchestrates the enhancement process, handling NSFW content detection,
 * model selection, and prompt generation with appropriate templates.
 */
class ContentCompliantEnhancementOrchestrator {
  /**
   * Main enhancement method that orchestrates the entire flow
   */
  async enhancePrompt(request: any) {
    const startTime = Date.now();
    
    try {
      // Build enhancement context
      const context = this.buildEnhancementContext(request);
      console.log('Enhancement context:', context);

      // Detect content tier for compliance
      const contentTier = this.detectContentTier(request.prompt);
      console.log('Detected content tier:', contentTier);

      // Get system prompt template based on context and content tier
      const template = this.getSystemPromptTemplate({ ...context, content_tier: contentTier });
      console.log('Selected template:', template);

      // Select optimal worker for enhancement
      const workerTarget = this.selectOptimalWorker(context);
      console.log('Selected worker:', workerTarget);

      // Try enhancement with selected worker
      let enhancementResult;
      if (workerTarget === 'chat') {
        enhancementResult = await this.tryInstructEnhancement(request, template);
      } else {
        enhancementResult = await this.tryBaseEnhancement(request, template);
      }

      // Post-process the enhancement
      const processedResult = this.postProcessEnhancement(enhancementResult.enhanced_prompt, context);

      // Track metrics
      await this.trackEnhancementMetrics(request, processedResult, template);

      return {
        enhanced_prompt: processedResult.enhanced_prompt,
        original_prompt: request.prompt,
        metadata: {
          ...enhancementResult.metadata,
          strategy: enhancementResult.strategy,
          content_tier: contentTier,
          model_used: enhancementResult.model_used,
          enhancement_time_ms: Date.now() - startTime,
          token_count: processedResult.token_count,
          compressed: processedResult.compressed,
          template_used: template.name
        }
      };

    } catch (error) {
      console.error('Enhancement failed:', error);
      return {
        enhanced_prompt: request.prompt,
        original_prompt: request.prompt,
        metadata: {
          strategy: 'error_fallback',
          content_tier: 'unrestricted',
          model_used: 'none',
          enhancement_time_ms: Date.now() - startTime,
          error: error.message
        }
      };
    }
  }

  /**
   * Detects content tier based on keywords and context
   */
  detectContentTier(prompt: string): 'artistic' | 'explicit' | 'unrestricted' {
    const lowerPrompt = prompt.toLowerCase();
    
    // Explicit content keywords
    const explicitKeywords = [
      'nude', 'naked', 'sex', 'sexual', 'porn', 'pornographic', 'xxx', 'adult',
      'erotic', 'sensual', 'intimate', 'aroused', 'orgasm', 'penetration',
      'masturbation', 'oral', 'anal', 'vagina', 'penis', 'breasts', 'nipples',
      'ass', 'pussy', 'cock', 'dick', 'cum', 'cumming', 'fucking', 'fuck',
      'horny', 'lustful', 'seductive', 'provocative', 'revealing', 'exposed'
    ];

    // Artistic nudity keywords (less explicit)
    const artisticKeywords = [
      'artistic nude', 'figure study', 'renaissance', 'classical', 'sculpture',
      'fine art', 'tasteful', 'elegant', 'artistic', 'beauty', 'form'
    ];

    // Check for explicit content
    const hasExplicit = explicitKeywords.some(keyword => lowerPrompt.includes(keyword));
    const hasArtistic = artisticKeywords.some(keyword => lowerPrompt.includes(keyword));

    if (hasExplicit && !hasArtistic) {
      return 'explicit';
    } else if (hasExplicit && hasArtistic) {
      return 'artistic';
    } else {
      return 'unrestricted';
    }
  }

  /**
   * Gets the appropriate system prompt template based on context
   */
  getSystemPromptTemplate(context: any) {
    const { job_type, quality, content_tier } = context;
    
    // SDXL Templates
    if (job_type?.includes('sdxl')) {
      if (quality === 'high') {
        return this.getSDXLHighPrompt(content_tier);
      } else {
        return this.getSDXLFastPrompt(content_tier);
      }
    }

    // WAN Templates
    if (job_type?.includes('wan') || job_type?.includes('video')) {
      if (quality === 'high') {
        return this.getWANHighPrompt(content_tier);
      } else {
        return this.getWANFastPrompt(content_tier);
      }
    }

    // Default to SDXL fast for image generation
    return this.getSDXLFastPrompt(content_tier);
  }

  /**
   * SDXL Fast enhancement prompts
   */
  getSDXLFastPrompt(contentTier: string) {
    const prompts = {
      artistic: {
        name: 'SDXL_Fast_Artistic',
        system_prompt: `You are an expert prompt engineer specializing in artistic content generation. Transform the user's prompt into a detailed, tasteful description that captures visual elements, composition, and aesthetic quality while maintaining artistic integrity. Focus on lighting, mood, texture, and creative elements. Keep content tasteful and artistic.

Guidelines:
- Enhance visual details and artistic elements
- Include lighting, composition, and mood descriptors  
- Maintain tasteful and artistic tone
- Add technical photography/art terms when appropriate
- Keep response under 150 tokens`,
        target_tokens: 150
      },
      explicit: {
        name: 'SDXL_Fast_Explicit',
        system_prompt: `You are an expert prompt engineer specializing in adult content generation. Transform the user's prompt into a detailed, explicit description that captures sensual details, intimate scenarios, and adult themes. Focus on visual elements, emotions, and explicit content while maintaining quality.

Guidelines:
- Enhance explicit visual details and intimate scenarios
- Include sensual descriptors and adult themes
- Be direct about explicit content
- Add mood and emotional elements
- Keep response under 150 tokens`,
        target_tokens: 150
      },
      unrestricted: {
        name: 'SDXL_Fast_General',
        system_prompt: `You are an expert prompt engineer. Transform the user's prompt into a detailed, high-quality description that captures visual elements, composition, lighting, and aesthetic details. Focus on creating vivid, artistic imagery.

Guidelines:
- Enhance visual details and composition
- Include lighting, mood, and texture descriptors
- Add technical photography/art terms
- Maintain high artistic quality
- Keep response under 150 tokens`,
        target_tokens: 150
      }
    };

    return prompts[contentTier] || prompts.unrestricted;
  }

  /**
   * SDXL High enhancement prompts
   */
  getSDXLHighPrompt(contentTier: string) {
    const prompts = {
      artistic: {
        name: 'SDXL_High_Artistic',
        system_prompt: `You are a master prompt engineer specializing in high-quality artistic content generation. Transform the user's prompt into an exceptionally detailed, tasteful description that captures every visual element, composition detail, and aesthetic quality while maintaining the highest artistic standards.

Guidelines:
- Create comprehensive visual descriptions with artistic integrity
- Include detailed lighting, composition, texture, and mood elements
- Add sophisticated artistic and technical terminology
- Maintain tasteful, museum-quality aesthetic
- Focus on visual storytelling and emotional resonance
- Keep response under 250 tokens`,
        target_tokens: 250
      },
      explicit: {
        name: 'SDXL_High_Explicit',
        system_prompt: `You are a master prompt engineer specializing in high-quality adult content generation. Transform the user's prompt into an exceptionally detailed, explicit description that captures every sensual detail, intimate scenario, and adult theme with artistic quality and emotional depth.

Guidelines:
- Create comprehensive explicit descriptions with high artistic quality
- Include detailed sensual elements, intimate positioning, and adult themes
- Add sophisticated descriptors for explicit content
- Maintain emotional depth and visual storytelling
- Be direct and detailed about adult content
- Keep response under 250 tokens`,
        target_tokens: 250
      },
      unrestricted: {
        name: 'SDXL_High_General',
        system_prompt: `You are a master prompt engineer specializing in exceptional visual content generation. Transform the user's prompt into an extraordinarily detailed, high-quality description that captures every visual element, composition detail, lighting nuance, and aesthetic quality with museum-level precision.

Guidelines:
- Create comprehensive, highly detailed visual descriptions
- Include sophisticated lighting, composition, texture, and mood elements
- Add advanced artistic and technical terminology
- Maintain exceptional artistic quality and visual storytelling
- Focus on creating masterpiece-level imagery
- Keep response under 250 tokens`,
        target_tokens: 250
      }
    };

    return prompts[contentTier] || prompts.unrestricted;
  }

  /**
   * WAN Fast enhancement prompts (for video)
   */
  getWANFastPrompt(contentTier: string) {
    const prompts = {
      artistic: {
        name: 'WAN_Fast_Artistic',
        system_prompt: `You are an expert prompt engineer specializing in artistic video content generation. Transform the user's prompt into a detailed, tasteful description that captures movement, visual elements, and artistic quality while maintaining tasteful content.

Guidelines:
- Enhance movement, action, and visual flow
- Include lighting, composition, and cinematic elements
- Maintain tasteful and artistic tone
- Add video/cinematography terms when appropriate
- Keep response under 120 tokens`,
        target_tokens: 120
      },
      explicit: {
        name: 'WAN_Fast_Explicit',
        system_prompt: `You are an expert prompt engineer specializing in adult video content generation. Transform the user's prompt into a detailed, explicit description that captures intimate movements, sensual scenarios, and adult themes with visual and emotional depth.

Guidelines:
- Enhance explicit movements and intimate scenarios
- Include sensual actions and adult themes
- Be direct about explicit video content
- Add emotional and visual elements
- Keep response under 120 tokens`,
        target_tokens: 120
      },
      unrestricted: {
        name: 'WAN_Fast_General',
        system_prompt: `You are an expert prompt engineer for video generation. Transform the user's prompt into a detailed description that captures movement, visual elements, cinematography, and dynamic action with high quality.

Guidelines:
- Enhance movement, action, and visual flow
- Include lighting, composition, and cinematic elements
- Add technical video/film terms
- Maintain high artistic quality
- Keep response under 120 tokens`,
        target_tokens: 120
      }
    };

    return prompts[contentTier] || prompts.unrestricted;
  }

  /**
   * WAN High enhancement prompts (for high-quality video)
   */
  getWANHighPrompt(contentTier: string) {
    const prompts = {
      artistic: {
        name: 'WAN_High_Artistic',
        system_prompt: `You are a master prompt engineer specializing in high-quality artistic video content generation. Transform the user's prompt into an exceptionally detailed, tasteful description that captures every movement, visual element, and cinematic quality while maintaining the highest artistic standards.

Guidelines:
- Create comprehensive movement and visual descriptions with artistic integrity
- Include detailed cinematography, lighting, and composition elements
- Add sophisticated film and artistic terminology
- Maintain tasteful, gallery-quality aesthetic
- Focus on visual storytelling and emotional resonance
- Keep response under 200 tokens`,
        target_tokens: 200
      },
      explicit: {
        name: 'WAN_High_Explicit',
        system_prompt: `You are a master prompt engineer specializing in high-quality adult video content generation. Transform the user's prompt into an exceptionally detailed, explicit description that captures every intimate movement, sensual scenario, and adult theme with cinematic quality and emotional depth.

Guidelines:
- Create comprehensive explicit movement descriptions with high artistic quality
- Include detailed sensual actions, intimate positioning, and adult themes
- Add sophisticated descriptors for explicit video content
- Maintain emotional depth and cinematic storytelling
- Be direct and detailed about adult video content
- Keep response under 200 tokens`,
        target_tokens: 200
      },
      unrestricted: {
        name: 'WAN_High_General',
        system_prompt: `You are a master prompt engineer specializing in exceptional video content generation. Transform the user's prompt into an extraordinarily detailed, high-quality description that captures every movement, visual element, cinematographic detail, and dynamic quality with film-level precision.

Guidelines:
- Create comprehensive, highly detailed movement and visual descriptions
- Include sophisticated cinematography, lighting, and composition elements
- Add advanced film and technical terminology
- Maintain exceptional artistic quality and visual storytelling
- Focus on creating cinematic masterpiece-level content
- Keep response under 200 tokens`,
        target_tokens: 200
      }
    };

    return prompts[contentTier] || prompts.unrestricted;
  }

  /**
   * Selects the optimal worker based on context and preferences
   */
  selectOptimalWorker(context: any): 'chat' | 'wan' {
    // For now, prefer chat worker for instruction-based enhancement
    // Can be made more sophisticated based on user preferences or performance metrics
    return 'chat';
  }

  /**
   * Post-processes the enhancement result for token optimization
   */
  postProcessEnhancement(enhancedPrompt: string, context: any) {
    const estimatedTokens = this.estimateTokens(enhancedPrompt);
    const tokenLimit = this.getTokenLimit(context.job_type, context.quality);
    
    let finalPrompt = enhancedPrompt;
    let compressed = false;

    // Compress if over token limit
    if (estimatedTokens > tokenLimit) {
      finalPrompt = this.intelligentCompress(enhancedPrompt, tokenLimit, ['redundancy', 'adjectives', 'articles']);
      compressed = true;
    }

    return {
      enhanced_prompt: finalPrompt,
      token_count: this.estimateTokens(finalPrompt),
      compressed,
      original_tokens: estimatedTokens
    };
  }

  /**
   * Intelligent compression strategies
   */
  intelligentCompress(prompt: string, targetTokens: number, strategies: string[]): string {
    let compressed = prompt;
    
    for (const strategy of strategies) {
      if (this.estimateTokens(compressed) <= targetTokens) break;
      
      switch (strategy) {
        case 'redundancy':
          // Remove redundant words and phrases
          compressed = compressed.replace(/\b(\w+)\s+\1\b/gi, '$1');
          compressed = compressed.replace(/,\s*,/g, ',');
          break;
        case 'adjectives':
          // Prioritize important adjectives, remove less important ones
          const words = compressed.split(' ');
          const importantWords = words.filter((word, index) => {
            const isAdjective = /ly$|ing$|ed$/.test(word);
            const isImportant = ['detailed', 'high', 'quality', 'beautiful', 'stunning'].some(important => 
              word.toLowerCase().includes(important));
            return !isAdjective || isImportant || index % 3 === 0; // Keep every 3rd adjective
          });
          compressed = importantWords.join(' ');
          break;
        case 'articles':
          // Remove unnecessary articles and prepositions
          compressed = compressed.replace(/\b(a|an|the)\s+/gi, '');
          compressed = compressed.replace(/\s+/g, ' ').trim();
          break;
      }
    }

    return compressed;
  }

  /**
   * Builds enhancement context from request
   */
  buildEnhancementContext(request: any) {
    return {
      job_type: request.job_type || 'sdxl_image_fast',
      quality: request.quality || 'fast',
      user_preferences: request.user_preferences || {},
      metadata: request.metadata || {}
    };
  }

  /**
   * Calls the appropriate worker with context
   */
  async callWorkerWithContext(workerTarget: 'chat' | 'wan', payload: any) {
    if (workerTarget === 'chat') {
      return await this.enhanceWithChatWorker(payload);
    } else {
      return await this.enhanceWithQwen(payload);
    }
  }

  /**
   * Track enhancement metrics for analytics
   */
  async trackEnhancementMetrics(request: any, processed: any, template: any) {
    // TODO: Implement analytics tracking
    console.log('Enhancement metrics:', {
      original_length: request.prompt?.length || 0,
      enhanced_length: processed.enhanced_prompt?.length || 0,
      template_used: template.name,
      compressed: processed.compressed
    });
  }
}

/**
 * Enhanced prompt enhancement with fallback strategies
 */
async function tryInstructEnhancement(request: any, template: any) {
  try {
    // Try chat worker first (Qwen Instruct)
    const chatResult = await enhanceWithChatWorker(request, template);
    return {
      enhanced_prompt: chatResult.enhanced_prompt,
      strategy: 'qwen_instruct',
      model_used: 'qwen_instruct',
      metadata: chatResult.metadata || {}
    };
  } catch (error) {
    console.log('Chat worker failed, trying WAN worker:', error.message);
    
    try {
      // Fallback to WAN worker (Qwen Base)
      const wanResult = await enhanceWithQwen(request, template);
      return {
        enhanced_prompt: wanResult.enhanced_prompt,
        strategy: 'qwen_base_fallback',
        model_used: 'qwen_base',
        metadata: { fallback_reason: error.message, ...wanResult.metadata }
      };
    } catch (wanError) {
      console.log('WAN worker also failed, using system prompt enhancement:', wanError.message);
      
      // Final fallback to system prompt enhancement
      const systemResult = await enhanceWithSystemPrompt(request, template);
      return {
        enhanced_prompt: systemResult.enhanced_prompt,
        strategy: 'system_prompt_fallback',
        model_used: 'system_prompt',
        metadata: { 
          chat_error: error.message, 
          wan_error: wanError.message,
          ...systemResult.metadata 
        }
      };
    }
  }
}

/**
 * Base model enhancement with fallback strategies
 */
async function tryBaseEnhancement(request: any, template: any) {
  try {
    // Try WAN worker first (Qwen Base)
    const wanResult = await enhanceWithQwen(request, template);
    return {
      enhanced_prompt: wanResult.enhanced_prompt,
      strategy: 'qwen_base',
      model_used: 'qwen_base',
      metadata: wanResult.metadata || {}
    };
  } catch (error) {
    console.log('WAN worker failed, trying system prompt enhancement:', error.message);
    
    try {
      // Fallback to system prompt enhancement
      const systemResult = await enhanceWithSystemPrompt(request, template);
      return {
        enhanced_prompt: systemResult.enhanced_prompt,
        strategy: 'system_prompt_fallback',
        model_used: 'system_prompt',
        metadata: { wan_error: error.message, ...systemResult.metadata }
      };
    } catch (systemError) {
      console.log('System prompt enhancement failed, using rule-based enhancement:', systemError.message);
      
      // Final fallback to rule-based enhancement
      const ruleResult = await enhanceForContent(request);
      return {
        enhanced_prompt: ruleResult.enhanced_prompt,
        strategy: 'rule_based_fallback',
        model_used: 'rule_based',
        metadata: { 
          wan_error: error.message, 
          system_error: systemError.message,
          ...ruleResult.metadata 
        }
      };
    }
  }
}

/**
 * Enhanced Qwen Base model calling
 */
async function enhanceWithQwen(request: any, template?: any) {
  const activeWorkerUrl = await getActiveWorkerUrl();
  if (!activeWorkerUrl) {
    throw new Error('No active WAN worker available');
  }

  const requestPayload = {
    inputs: template ? 
      `${template.system_prompt}\n\nOriginal prompt: ${request.prompt}` : 
      `Enhance this prompt for high-quality image generation: ${request.prompt}`,
    parameters: {
      max_new_tokens: template?.target_tokens || 150,
      temperature: 0.7,
      top_p: 0.9,
      do_sample: true,
      return_full_text: false
    }
  };

  console.log('Calling WAN worker with payload:', requestPayload);

  const response = await fetch(`${activeWorkerUrl}/generate`, {
    method: 'POST',
    headers: {
      'Content-Type': 'application/json',
      'Authorization': `Bearer ${Deno.env.get('WAN_WORKER_API_KEY')}`
    },
    body: JSON.stringify(requestPayload)
  });

  if (!response.ok) {
    const errorText = await response.text();
    throw new Error(`WAN worker request failed: ${response.status} - ${errorText}`);
  }

  const result = await response.json();
  
  if (!result.generated_text) {
    throw new Error('Invalid response from WAN worker');
  }

  return {
    enhanced_prompt: result.generated_text.trim(),
    metadata: {
      model: 'qwen_base',
      tokens_generated: result.generated_text.length / 4, // Rough estimate
      worker_url: activeWorkerUrl
    }
  };
}

/**
 * Quality-aware tag addition for SDXL
 */
function addSDXLQualityTags(prompt: string, quality: string = 'fast', contentTier: string = 'unrestricted'): string {
  let qualityTags = '';
  
  if (quality === 'high') {
    qualityTags = ', masterpiece, best quality, ultra detailed, 8k, professional, high resolution';
  } else {
    qualityTags = ', high quality, detailed, professional';
  }

  // Add content-appropriate tags
  if (contentTier === 'explicit') {
    qualityTags += ', sensual, intimate, adult content';
  } else if (contentTier === 'artistic') {
    qualityTags += ', artistic, tasteful, elegant';
  }

  return prompt + qualityTags;
}

/**
 * Quality-aware tag addition for WAN Video
 */
function addWANVideoQualityTags(prompt: string, quality: string = 'fast', contentTier: string = 'unrestricted'): string {
  let qualityTags = '';
  
  if (quality === 'high') {
    qualityTags = ', cinematic, high quality, smooth motion, professional video, 4k';
  } else {
    qualityTags = ', smooth motion, good quality, clear video';
  }

  // Add content-appropriate tags
  if (contentTier === 'explicit') {
    qualityTags += ', intimate, sensual, adult video';
  } else if (contentTier === 'artistic') {
    qualityTags += ', artistic, cinematic, elegant movement';
  }

  return prompt + qualityTags;
}

/**
 * Quality-aware tag addition for WAN Image
 */
function addWANImageQualityTags(prompt: string, quality: string = 'fast', contentTier: string = 'unrestricted'): string {
  let qualityTags = '';
  
  if (quality === 'high') {
    qualityTags = ', high quality, detailed, professional, clear, sharp';
  } else {
    qualityTags = ', good quality, clear, detailed';
  }

  // Add content-appropriate tags
  if (contentTier === 'explicit') {
    qualityTags += ', sensual, intimate, adult content';
  } else if (contentTier === 'artistic') {
    qualityTags += ', artistic, tasteful, elegant';
  }

  return prompt + qualityTags;
}

/**
 * Enhanced SDXL fallback enhancement
 */
async function enhanceForSDXL(request: any): Promise<{ enhanced_prompt: string; metadata: any }> {
  const { prompt, quality = 'fast', content_tier = 'unrestricted' } = request;
  
  let enhanced = prompt;
  
  // Add descriptive elements based on content tier
  if (content_tier === 'explicit') {
    enhanced = `Highly detailed explicit scene: ${enhanced}, sensual lighting, intimate atmosphere, adult themes`;
  } else if (content_tier === 'artistic') {
    enhanced = `Artistic composition: ${enhanced}, dramatic lighting, tasteful presentation, museum quality`;
  } else {
    enhanced = `Detailed artistic scene: ${enhanced}, professional lighting, high composition quality`;
  }
  
  // Add quality tags
  enhanced = addSDXLQualityTags(enhanced, quality, content_tier);
  
  return {
    enhanced_prompt: enhanced,
    metadata: {
      strategy: 'rule_based_sdxl',
      quality,
      content_tier
    }
  };
}

/**
 * Enhanced WAN Video fallback enhancement
 */
async function enhanceForWANVideo(request: any): Promise<{ enhanced_prompt: string; metadata: any }> {
  const { prompt, quality = 'fast', content_tier = 'unrestricted' } = request;
  
  let enhanced = prompt;
  
  // Add movement and video elements based on content tier
  if (content_tier === 'explicit') {
    enhanced = `Intimate video scene: ${enhanced}, sensual movements, adult interaction, emotional connection`;
  } else if (content_tier === 'artistic') {
    enhanced = `Cinematic artistic video: ${enhanced}, graceful movement, artistic cinematography, elegant flow`;
  } else {
    enhanced = `Dynamic video scene: ${enhanced}, smooth movement, engaging action, professional cinematography`;
  }
  
  // Add quality tags
  enhanced = addWANVideoQualityTags(enhanced, quality, content_tier);
  
  return {
    enhanced_prompt: enhanced,
    metadata: {
      strategy: 'rule_based_wan_video',
      quality,
      content_tier
    }
  };
}

/**
 * Enhanced WAN Image fallback enhancement
 */
async function enhanceForWANImage(request: any): Promise<{ enhanced_prompt: string; metadata: any }> {
  const { prompt, quality = 'fast', content_tier = 'unrestricted' } = request;
  
  let enhanced = prompt;
  
  // Add descriptive elements based on content tier
  if (content_tier === 'explicit') {
    enhanced = `Detailed explicit image: ${enhanced}, sensual presentation, intimate details, adult themes`;
  } else if (content_tier === 'artistic') {
    enhanced = `Artistic image composition: ${enhanced}, professional presentation, tasteful aesthetic, gallery quality`;
  } else {
    enhanced = `High-quality image: ${enhanced}, professional composition, detailed presentation`;
  }
  
  // Add quality tags
  enhanced = addWANImageQualityTags(enhanced, quality, content_tier);
  
  return {
    enhanced_prompt: enhanced,
    metadata: {
      strategy: 'rule_based_wan_image',
      quality,
      content_tier
    }
  };
}

/**
 * Content-aware enhancement router
 */
async function enhanceForContent(request: any): Promise<{ enhanced_prompt: string; metadata: any }> {
  const jobType = request.job_type || 'sdxl_image_fast';
  
  if (jobType.includes('sdxl')) {
    return await enhanceForSDXL(request);
  } else if (jobType.includes('video')) {
    return await enhanceForWANVideo(request);
  } else if (jobType.includes('wan')) {
    return await enhanceForWANImage(request);
  } else {
    // Default to SDXL
    return await enhanceForSDXL(request);
  }
}

/**
 * Gets active worker URL from Supabase
 */
async function getActiveWorkerUrl(): Promise<string | null> {
  try {
    const supabase = createClient(
      Deno.env.get('SUPABASE_URL') ?? '',
      Deno.env.get('SUPABASE_SERVICE_ROLE_KEY') ?? ''
    );

    const { data, error } = await supabase.functions.invoke('get-active-worker-url', {
      body: { worker_type: 'wan' }
    });

    if (error) {
      console.error('Error getting active worker URL:', error);
      return null;
    }

    return data?.worker_url || null;
  } catch (error) {
    console.error('Failed to get active worker URL:', error);
    return null;
  }
}

/**
 * Gets chat worker URL for instruction-based enhancement
 */
async function getChatWorkerUrl(): Promise<string | null> {
  try {
    const supabase = createClient(
      Deno.env.get('SUPABASE_URL') ?? '',
      Deno.env.get('SUPABASE_SERVICE_ROLE_KEY') ?? ''
    );

    // First try to get from active workers
    const { data: activeData, error: activeError } = await supabase.functions.invoke('get-active-worker-url', {
      body: { worker_type: 'chat' }
    });

    if (!activeError && activeData?.worker_url) {
      return activeData.worker_url;
    }

    // Fallback to discovering chat workers
    return await discoverChatWorker();
  } catch (error) {
    console.error('Failed to get chat worker URL:', error);
    return null;
  }
}

/**
 * Discovers chat worker from database or RunPod
 */
async function discoverChatWorker(): Promise<string | null> {
  try {
    const supabase = createClient(
      Deno.env.get('SUPABASE_URL') ?? '',
      Deno.env.get('SUPABASE_SERVICE_ROLE_KEY') ?? ''
    );

    // Try to get from registered chat workers
    const { data, error } = await supabase
      .from('chat_workers')
      .select('worker_url, status')
      .eq('status', 'active')
      .order('updated_at', { ascending: false })
      .limit(1)
      .single();

    if (error || !data) {
      console.log('No active chat workers found in database, trying RunPod discovery');
      
      // Fallback to RunPod pod discovery
      const podId = await getPodId();
      if (podId) {
        return `https://${podId}-8000.proxy.runpod.net`;
      }
      
      return null;
    }

    return data.worker_url;
  } catch (error) {
    console.error('Error discovering chat worker:', error);
    return null;
  }
}

/**
 * Estimates token count for a given text
 */
function estimateTokens(text: string): number {
  // Rough estimation: ~4 characters per token for English text
  return Math.ceil(text.length / 4);
}

/**
 * Gets token limit based on job type and quality
 */
function getTokenLimit(jobType: string, quality: string): number {
  const limits = {
    sdxl: quality === 'high' ? 250 : 150,
    wan: quality === 'high' ? 200 : 120,
    default: 150
  };

  if (jobType?.includes('sdxl')) {
    return limits.sdxl;
  } else if (jobType?.includes('wan') || jobType?.includes('video')) {
    return limits.wan;
  }

  return limits.default;
}

/**
 * SDXL prompt compression
 */
function compressForSDXL(prompt: string, targetTokens: number = 150): string {
  let compressed = prompt;
  const currentTokens = estimateTokens(compressed);
  
  if (currentTokens <= targetTokens) {
    return compressed;
  }

  // Remove redundant adjectives
  compressed = compressed.replace(/\b(very|extremely|highly|incredibly|amazingly)\s+/gi, '');
  
  // Compress common phrases
  compressed = compressed.replace(/high quality, detailed/gi, 'detailed');
  compressed = compressed.replace(/professional, high resolution/gi, 'professional');
  
  // Remove excessive commas
  compressed = compressed.replace(/,\s*,/g, ',');
  compressed = compressed.replace(/\s+/g, ' ').trim();

  return compressed;
}

/**
 * Checks chat worker availability and model status
 */
async function checkChatWorkerAvailability(workerUrl: string): Promise<boolean> {
  try {
    const healthResponse = await fetch(`${workerUrl}/health`, {
      method: 'GET',
      headers: {
        'Authorization': `Bearer ${Deno.env.get('WAN_WORKER_API_KEY')}`
      }
    });

    if (!healthResponse.ok) {
      return false;
    }

    const healthData = await healthResponse.json();
    
    // Check if model is loaded and ready
    return healthData.status === 'healthy' && 
           healthData.model_loaded === true &&
           healthData.ready === true;
  } catch (error) {
    console.error('Error checking chat worker availability:', error);
    return false;
  }
}

/**
 * Enhanced chat worker interaction with job type context
 */
async function enhanceWithChatWorker(request: any, template?: any) {
  const chatWorkerUrl = await getChatWorkerUrl();
  if (!chatWorkerUrl) {
    throw new Error('No chat worker available');
  }

  // Check worker availability
  const isAvailable = await checkChatWorkerAvailability(chatWorkerUrl);
  if (!isAvailable) {
    throw new Error('Chat worker is not ready or model not loaded');
  }

  const systemPrompt = template?.system_prompt || 
    'You are an expert prompt engineer. Enhance the following prompt for high-quality content generation:';

  const requestPayload = {
    model: "Qwen/Qwen2.5-7B-Instruct",
    messages: [
      {
        role: "system",
        content: systemPrompt
      },
      {
        role: "user", 
        content: `Job Type: ${request.job_type || 'sdxl_image_fast'}\nQuality: ${request.quality || 'fast'}\n\nOriginal prompt: ${request.prompt}`
      }
    ],
    max_tokens: template?.target_tokens || 150,
    temperature: 0.7,
    top_p: 0.9,
    stream: false
  };

  console.log('Calling chat worker with payload:', requestPayload);

  const response = await fetch(`${chatWorkerUrl}/v1/chat/completions`, {
    method: 'POST',
    headers: {
      'Content-Type': 'application/json',
      'Authorization': `Bearer ${Deno.env.get('WAN_WORKER_API_KEY')}`
    },
    body: JSON.stringify(requestPayload)
  });

  if (!response.ok) {
    const errorText = await response.text();
    throw new Error(`Chat worker request failed: ${response.status} - ${errorText}`);
  }

  const result = await response.json();
  
  if (!result.choices?.[0]?.message?.content) {
    throw new Error('Invalid response from chat worker');
  }

  return {
    enhanced_prompt: result.choices[0].message.content.trim(),
    metadata: {
      model: 'qwen_instruct',
      tokens_generated: result.usage?.completion_tokens || 0,
      worker_url: chatWorkerUrl,
      template_used: template?.name || 'default'
    }
  };
}

/**
 * System prompt enhancement using WAN worker
 */
async function enhanceWithSystemPrompt(request: any, template: any) {
  const activeWorkerUrl = await getActiveWorkerUrl();
  if (!activeWorkerUrl) {
    throw new Error('No active worker available for system prompt enhancement');
  }

  const systemEnhancedPrompt = `${template.system_prompt}\n\nOriginal: ${request.prompt}`;

  const requestPayload = {
    inputs: systemEnhancedPrompt,
    parameters: {
      max_new_tokens: template.target_tokens || 100,
      temperature: 0.6,
      top_p: 0.85,
      do_sample: true,
      return_full_text: false
    }
  };

  const response = await fetch(`${activeWorkerUrl}/generate`, {
    method: 'POST',
    headers: {
      'Content-Type': 'application/json',
      'Authorization': `Bearer ${Deno.env.get('WAN_WORKER_API_KEY')}`
    },
    body: JSON.stringify(requestPayload)
  });

  if (!response.ok) {
    const errorText = await response.text();
    throw new Error(`System prompt enhancement failed: ${response.status} - ${errorText}`);
  }

  const result = await response.json();
  
  return {
    enhanced_prompt: result.generated_text?.trim() || request.prompt,
    metadata: {
      model: 'qwen_base_system',
      enhancement_method: 'system_prompt',
      worker_url: activeWorkerUrl
    }
  };
}

/**
 * Gets RunPod pod ID for worker discovery
 */
async function getPodId(): Promise<string | null> {
  try {
    // Try to get pod ID from environment or metadata service
    const podId = Deno.env.get('RUNPOD_POD_ID');
    if (podId) {
      return podId;
    }

    // If running on RunPod, try metadata service
    try {
      const metadataResponse = await fetch('http://metadata.google.internal/computeMetadata/v1/instance/attributes/runpod-pod-id', {
        headers: { 'Metadata-Flavor': 'Google' }
      });
      
      if (metadataResponse.ok) {
        return await metadataResponse.text();
      }
    } catch (metadataError) {
      // Metadata service not available, continue
    }

    return null;
  } catch (error) {
    console.error('Error getting pod ID:', error);
    return null;
  }
}

/**
 * Gets descriptive strategy name for logging
 */
function getEnhancementStrategy(strategy: string, model: string): string {
  const strategies = {
    'qwen_instruct': 'Qwen Instruct Enhancement',
    'qwen_base': 'Qwen Base Enhancement', 
    'qwen_base_fallback': 'Qwen Base (Fallback)',
    'system_prompt_fallback': 'System Prompt (Fallback)',
    'rule_based_fallback': 'Rule-based (Final Fallback)',
    'error_fallback': 'Error Fallback'
  };

  return strategies[strategy] || `${strategy} (${model})`;
}